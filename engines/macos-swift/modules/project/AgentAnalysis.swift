import Foundation

/// Lifecycle status of an Agent Mode run.
public enum AgentJobStatus: String, Codable, CaseIterable {
    case queued
    case running
    case completed
    case failed
    case cancelled
    case blocked
}

/// Artifact kinds generated by Agent Mode runs.
public enum AgentArtifactKind: String, Codable, CaseIterable {
    case transcriptFullV1 = "transcript.full.v1"
    case transcriptWordsV1 = "transcript.words.v1"
    case beatMapV1 = "beat-map.v1"
    case qaReportV1 = "qa-report.v1"
    case cutPlanV1 = "cut-plan.v1"
    case runSummaryV1 = "run-summary.v1"
}

/// Project-relative artifact entry emitted by an Agent Mode run.
public struct AgentArtifactReference: Codable, Equatable {
    public var kind: AgentArtifactKind
    public var path: String

    public init(kind: AgentArtifactKind, path: String) {
        self.kind = kind
        self.path = path
    }
}

/// Beat coverage report for Agent Mode QA gating.
public struct AgentQACoverage: Codable, Equatable {
    public var hook: Bool
    public var action: Bool
    public var payoff: Bool
    public var takeaway: Bool

    public init(hook: Bool, action: Bool, payoff: Bool, takeaway: Bool) {
        self.hook = hook
        self.action = action
        self.payoff = payoff
        self.takeaway = takeaway
    }
}

/// Narrative QA report generated for each Agent Mode run.
public struct AgentQAReport: Codable, Equatable {
    public var passed: Bool
    public var score: Double
    public var coverage: AgentQACoverage
    public var missingBeats: [String]

    public init(passed: Bool, score: Double, coverage: AgentQACoverage, missingBeats: [String]) {
        self.passed = passed
        self.score = score
        self.coverage = coverage
        self.missingBeats = missingBeats
    }
}

/// Summary metadata for a single Agent Mode run.
public struct AgentRunMetadata: Codable, Equatable, Identifiable {
    public var id: String
    public var status: AgentJobStatus
    public var runtimeBudgetMinutes: Int
    public var createdAt: Date
    public var updatedAt: Date
    public var qaReport: AgentQAReport?
    public var errorCode: String?
    public var errorMessage: String?
    public var artifacts: [AgentArtifactReference]

    public init(
        id: String,
        status: AgentJobStatus,
        runtimeBudgetMinutes: Int,
        createdAt: Date,
        updatedAt: Date,
        qaReport: AgentQAReport? = nil,
        errorCode: String? = nil,
        errorMessage: String? = nil,
        artifacts: [AgentArtifactReference] = []
    ) {
        self.id = id
        self.status = status
        self.runtimeBudgetMinutes = runtimeBudgetMinutes
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.qaReport = qaReport
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.artifacts = artifacts
    }
}

/// Project-level index of Agent Mode runs and latest apply state.
public struct AgentAnalysisMetadata: Codable, Equatable {
    public var latestRunID: String?
    public var latestAppliedRunID: String?
    public var latestRunSummaryPath: String?
    /// Legacy v4 field decoded for forward-compatibility only.
    public var legacyRuns: [AgentRunMetadata]

    public init(
        latestRunID: String? = nil,
        latestAppliedRunID: String? = nil,
        latestRunSummaryPath: String? = nil,
        legacyRuns: [AgentRunMetadata] = []
    ) {
        self.latestRunID = latestRunID
        self.latestAppliedRunID = latestAppliedRunID
        self.latestRunSummaryPath = latestRunSummaryPath
        self.legacyRuns = legacyRuns
    }

    private enum CodingKeys: String, CodingKey {
        case latestRunID
        case latestAppliedRunID
        case latestRunSummaryPath
        case runs
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        latestRunID = try container.decodeIfPresent(String.self, forKey: .latestRunID)
        latestAppliedRunID = try container.decodeIfPresent(String.self, forKey: .latestAppliedRunID)
        latestRunSummaryPath = try container.decodeIfPresent(String.self, forKey: .latestRunSummaryPath)
        legacyRuns = try container.decodeIfPresent([AgentRunMetadata].self, forKey: .runs) ?? []
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(latestRunID, forKey: .latestRunID)
        try container.encodeIfPresent(latestAppliedRunID, forKey: .latestAppliedRunID)
        try container.encodeIfPresent(latestRunSummaryPath, forKey: .latestRunSummaryPath)
        // Intentionally omits legacy `runs` to keep run-summary as canonical state.
    }
}
